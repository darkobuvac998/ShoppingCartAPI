
node {
  stage('GIT CHECKOUT') {
    checkout scmGit(branches: [[name: 'dev']], submoduleCfg: [], extensions: [[$class: 'LocalBranch', localBranch: '**']], doGenerateSubmoduleConfigurations: false, userRemoteConfigs: [[credentialsId: 'jenkins-github', url: 'git@github.com:darkobuvac998/ShoppingCartAPI.git']])
  }

  stage('NOTIFY SLACK') {
    sh "echo BUILD STARTED AT: ${new Date().format('dd-MM-yyyy HH:mm:ss')}"
  }

  stage('SET ENVIRONMENT VARIABLES') {
    env.IMAGE_VERSION = "v_${BUILD_NUMBER}"
    env.IMAGE_PREFIX = 'codaxy_'
    env.GIT_BRANCH = getCurrentBranch()
    env.GIT_COMMIT_HASH = getShortCommitHash()
    env.GIT_COMMIT_AUTHOR = getCommitAuthorName()
    env.GIT_COMMIT_MESSAGE = getCommitMessage()
    env.GIT_COMMIT_AUTHOR_EMAIL = getCommitAuthorEmail()
    env.GIT_CHANGES = getChangeSet()
    env.IMAGE_TAG = getDockerImageTag()

    sh "echo ${env.IMAGE_TAG} ${env.GIT_BRANCH}"
  }

  stage('BUILD DOCKER IMAGES') {
    parallel ADMINISTRATION: {
      node {
        label 'dotnet-agent'
      }
      getBuildStages('administration').call()
    },
    CONDUCTOR: {
      node {
        label 'dotnet-agent'
      }
      getBuildStages('conductor').call()
    },
    INFOBLOX: {
      node {
        label 'dotnet-agent'
      }
      getBuildStages('infoblox').call()
    }
  }

  stage('LIST ALL DOCKER IMAGES') {
    node {
      label 'dotnet-agent'
    }

    sh 'docker image ls | grep codaxy'
  }

  stage('PUBLISH REPORTS') {
    def reportName = "SP1NE-${env.IMAGE_TAG}-BUILD_${env.BUILD_NUMBER}_${new Date().format('dd-MM-yyyy HH:mm:ss')}"

    sh "./generate-html-report.sh"

    publishHTML(
      target : [allowMissing: false,
                alwaysLinkToLastBuild: true,
                keepAll: true,
                reportDir: 'reports',
                reportFiles: 'index.html',
                reportName: "buildreport",
                reportTitles: "SP1NE-${env.IMAGE_TAG}-BUILD_${env.BUILD_NUMBER}"
              ]
    )
  }

  stage('NOTIFY SLACK') {
    sh "echo BUILD ${currentBuild.result} AT: ${new Date().format('dd-MM-yyyy HH:mm:ss')}"
  }

  if (getImagesToRemove() != '') {
    stage('CLEANUP') {
        sh 'docker container prune -f'
        sh 'docker rmi $(docker images --filter "dangling=true" -q --no-trunc)'
    }
  }
}

def getBuildStages(service, useCredentials = false, credentialsName = '', pwdVariable = '', usernameVariable = '') {
  return {
    def oldHash
    def newHash
    def imageExists

    def imageName = "${env.IMAGE_PREFIX}${service}"

    stage('CHECK DOES IMAGE EXISTS') {
      imageExists = doesImageExists("${imageName}:${env.IMAGE_TAG}")
      sh "echo Checkind does ${imageName}${env.IMAGE_TAG} exists"
    }

    if (imageExists != '') {
      stage('GET OLD IMAGE HASH') {
        oldHash = getImageHash("${imageName}:${env.IMAGE_TAG}")
        sh "echo ${oldHash}"
      }
    }

    if (useCredentials == true) {
      stage('BUILD DOCKER IMAGE') {
        withCredentials([usernamePassword(credentialsId: "${credentialsName}", passwordVariable: "${pwdVariable}", usernameVariable: "${usernameVariable}")]) {
          sh "docker build -t ${imageName}:${env.IMAGE_TAG} --build-arg TMF_PAT_USERNAME=${usernameVariable} --build-arg TMF_PAT=${pwdVariable} -f docker/${service}/Dockerfile ."
          newHash = getImageHash("${imageName}:${env.IMAGE_TAG}")
          sh "echo ${newHash}"
        }
      }
    }else {
      stage('BUILD DOCKER IMAGE') {
        sh "docker build -t ${imageName}:${env.IMAGE_TAG} -f docker/Dockerfile ."
        newHash = getImageHash("${imageName}:${env.IMAGE_TAG}")
        sh "echo ${newHash}"
      }
    }

    if (oldHash != newHash) {
      stage('PACK IMAGE') {
        sh "docker save ${imageName}:${env.IMAGE_TAG} | gzip > ../sp1ne/images/${imageName}:${env.IMAGE_TAG}.tar.gz"
      }
      stage('DEPLOY IMAGE') {
        sh "Deploying ${imageName}:${env.IMAGE_TAG}..."
      }
    }else {
      stage('DEPLOY SKIPPED') {
        echo('There are no changes. Skipping deployment.')
      }
    }
  }
}

def getImageHash(image) {
  return sh(returnStdout: true, script: "docker inspect -f \"{{.Id}}\" ${image}").trim()
}

def getShortCommitHash() {
  return sh(returnStdout: true, script: "git log -n 1 --pretty=format:'%h'").trim()
}

def getCommitAuthorName() {
  return sh(returnStdout: true, script: 'git log -1 --pretty=format:"%an"').trim()
}

def getCommitAuthorEmail() {
  return sh(returnStdout: true, script: 'git show -s --pretty=%ae').trim()
}

def getCommitMessage() {
  return sh(script: 'git log -1 --pretty=%B', returnStdout: true).trim()
}

def getChangeSet() {
  return sh(returnStdout: true, script: 'git diff-tree --no-commit-id --name-status -r HEAD').trim()
}

def getChangeLog() {
  return sh(returnStdout: true, script: "git log --date=short --pretty=format:'%ad %aN <%ae> %n%n%x09* %s%d%n%b'").trim()
}

def doesImageExists(imageName) {
  return sh(returnStdout: true, script: "docker images -q ${imageName}").trim()
}

def getCurrentBranch () {
  return sh(
          script: 'git name-rev --name-only HEAD',
          returnStdout: true
  ).trim()
}

def getImagesToRemove() {
  return sh(returnStdout: true, script: "docker images --filter \"dangling=true\" -q --no-trunc").trim()
}

def getDockerImageTag() {
  if (env.GIT_BRANCH == 'dev') {
    return 'dev'
  }
  if (env.GIT_BRANCH == 'staging') {
    return 'uat'
  }
  return 'latest'
}

def sendNotificationViaSlack() {
}
